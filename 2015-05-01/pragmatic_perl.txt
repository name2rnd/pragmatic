Рефакторинг Legacy

Pre: Очень бы хотелось превратить это в цикл статей про рефакторинг наследия, но пока обещать ничего не буду.

В отличие, пожалуй, от многих программистов, которые очень не любят легаси-код, для меня рефакторинг такого кода это какое-то особенное удовольствие. Возможно, женская натура любит убирать бардак.

Рефакторинг бывает двух видов: невменяемый и вменяемый.
Невменяемый рефакторинг это процесс ради процесса. Увидел новый подход и сразу "давайте перепишем!". Но если ты работаешь в коммерческой структуре - это недопустимо. Никто не будет платить тебе за то, чтобы ты "поигрался с новым кодом". К тому же, гипер-рефакторинг рискует вообще не перейти в продакшн по причине своей глобальности. Поэтому он должен быть разумен и обоснован. Например, если нужно добавить или изменить функционал, а ты смотришь на древний код, который итерационно приобретал все больше и больше костылей и ветвлений, и решаешь, что так больше продолжаться не может.
Но как всегда тот кусок кода, который нужно заменить, это функция-мутант ростом в три-четыре сотни строк, в лучшем случае.

Пусть у нас будет такой искуственный пример:
  1 package Human;
  2 use strict; use warnings;
  3 
  4 sub do {
  5     my $logger = shift;
  6     my $text = shift;
  7     my $key = shift;
  8     if ($key ne 'rree') {
  9 
 10         # ... some code
 11 
 12         # normalize
 13         $text =~ s/[!\-\+]/ ! /g;
 14         $text =~ s/\(\(/ ( /g;
 15         $text =~ s/\)\)/ ); /g;
 16         if ($text =~ /superpower/) {
 17             $logger->log('warn', 'superpower used');
 18             $text =~ s/superpower/secret weapon/g;
 19         }
 20         # ... more normalize rules
 21 
 22         # ... some code
 23 
 24         # prepare
 25         $text = sprintf '%s %s', $text, $key;
 26         unless ($text) {
 27             $logger->log('warning', 'no text');
 28         }
 29     }
 30     elsif ($key eq 'jjii') {
 31         # ...
 32     }
 33 
 34     return $text;
 35 }
 36 1;

Допустим, в блок кода, где мы нормализуем переменную text, мне нужно добавить еще одну регулярку, например, такую:
$text =~ s/gg|rr|e|t|q//g;

В моем примере блок регулярок не очень большой, потому что он сильно упрощен. Казалось бы, что вполне можно еще добавлять и добавлять. Но все равно наступит тот момент времени, когда это выйдет за рамки разумного.

Лучший друг рефакторинга это TDD - Test-driven development (Разработка через тестирование), потому что мы хотим не просто сделать красиво, но чтобы оно еще и работало как раньше.
Начнем с написания теста. Классически имя теста формируется по шаблону t-<MODULE>.t, поэтому наш тест назовем t-human.t

И вот так он будет выглядеть:
  1 #!/usr/bin/perl
  2 use strict;
  3 use Data::Dumper;
  4 use Test::More;
  5 
  6 use_ok('Human');
  7 
  8 done_testing();

Запустив в консоли:
$ prove t-human.t 

Увидим такой результат:
t-human.t .. ok   
All tests successful.
Files=1, Tests=1,  0 wallclock secs ( 0.01 usr  0.00 sys +  0.01 cusr  0.00 csys =  0.02 CPU)
Result: PASS

Конечно тесты пройдены, там же проверяется только use, а фрагмен с рабочего проекта.

Дальше выносим нашего пациента в отдельную функцию. Здесь мы получаем сразу несколько плюсов: код становится чище и понятнее, а отдельно вынесенную функцию можно нормально тестировать, не ударяясь в тестирование функции do (допустим, тестов для нее никогда не было и функционал ее безграничен)

Теперь у нас такой код:

  8     if ($key ne 'rree') {
  9 
 10         # ... some code    
 11         # normalize
 12         my $text = _normalize($logger, $text);
 13 
 14         # ... some code
 15         
 16         # prepare
 17         $text = sprintf '%s %s', $text, $key;
 18         unless ($text) {
 19             $logger->log('warning', 'no text');
 20         }
 21     }
 22     elsif ($key eq 'jjii') {
 23         # ...
 24     }
 25 
 26     return $text;
 27 }
 28 
 29 sub _normalize { 
 30     my ($logger, $text) = @_;
 31     $text =~ s/[!\-\+]/ ! /g;
 32     $text =~ s/\(\(/ ( /g;
 33     $text =~ s/\)\)/ ); /g;
 34     if ($text =~ /superpower/) {
 35         $logger->log('warn', 'superpower used');
 36         $text =~ s/superpower/secret weapon/g;
 37     }
 38     # ... more normalize rules
 39     return $text;
 40 }
 41 1;

$ prove t-human.t 
до сих пор работает, показывая, что синтаксически все ОК.

Наша задача не просто вынести в фукцию, но еще и дописать ее, сохранив прежний функционал. Поэтому пишем тест для текущей логики:

 10 my $tests = {
 11     '!abc+' => ' ! abc ! ',
 12     '((bbb))' => ' ( bbb ); ',
 13     'i want to use superpower' => 'i want to use secret weapon',
 14 };

 13 for my $t (keys %$tests) {
 14     is Human::_normalize($logger, $t), $test->{$t};
 15 }

Но вот чертовщина! Функция имеет зависимость от неведомого $logger, у которого еще и методы вызывает. Просто передать undef не сработает. Здесь нужно себя перебороть и не удариться в невменяемый рефакторинг, пытаясь избавиться от этой зависимости. Пока будет достаточно просто вынести в функцию и на этом успокоиться.
Но я не хочу писать сообщения в непонятный лог, я хочу их просто вывести в консоль и только в режиме -v
"ref $logger" подсказывает, что это объект класса Logger. Ок, будем использовать его, но заменив метод log

Делаем Mock с помощью Test::Mock::Simple
и теперь наш фрагмент теста выглядит вот так:

 17 # mock
 18 my $mock = Test::Mock::Simple->new(module => 'Logger');
 19 $mock->add(log => sub { shift; note explain ['IN MOCK', @_] });
 20 my $logger = Logger->new();

 21 for my $t (keys %$tests) {
 22     is Human::_normalize($logger, $t), $tests->{$t};
 23 }

Здесь мы заменяем метод log объекта Logger на простой вывод в консоль в режиме -v (метод note), а explain отдает человеко-понятный дамп стека.

Запускаем тест:
$ prove t-human.t
t-human.t .. ok   
All tests successful.
Files=1, Tests=5,  0 wallclock secs ( 0.01 usr  0.00 sys +  0.01 cusr  0.00 csys =  0.02 CPU)
Result: PASS

И вот так будет выглядеть вывод при использовании режима verbose:
$ prove t-human.t -v
t-human.t .. 
ok 1 - use Human;
ok 2 - use Logger;
# [
#   'IN MOCK',
#   'warn',
#   'superpower used'
# ]
ok 3
ok 4
ok 5
1..5
ok
All tests successful.
Files=1, Tests=5,  0 wallclock secs ( 0.01 usr  0.00 sys +  0.01 cusr  0.00 csys =  0.02 CPU)
Result: PASS

Теперь, когда мы знаем, что наша функция нормально работает на старых данных, можно расширять ее функционал.
Конечно, тестовый массив в общем случае значительно больше, чем в этом примере. Тут нужно руководствоваться просто здравым смыслом.

Сначала дописываем тесты для нового функционала:
 10 my $tests = {
 11     '!abc+' => ' ! abc ! ',
 12     '((bbb))' => ' ( bbb ); ',
 13     'i want to use superpower' => 'i want to use secret weapon',
 14     'gg' => '',
 15     '!ggabcrr))' => ' ! abc ); ',
 16 };

Затем я всегда проверяю, что мой тест действительно перестал работать. Это паранойя? Но вдруг...

t-human.t .. 1/? 
#   Failed test at t-human.t line 23.
#          got: ' ! ggabcrr ); '
#     expected: ' ! abc ); '

#   Failed test at t-human.t line 23.
#          got: 'gg'
#     expected: ''
# Looks like you failed 2 tests of 7.

Дописываем логику в код:
 29 sub _normalize {
 30     my ($logger, $text) = @_;
 31     $text =~ s/[!\-\+]/ ! /g;
 32     $text =~ s/\(\(/ ( /g;
 33     $text =~ s/\)\)/ ); /g;
 34     $text =~ s/gg|rr|e|t|q//g;
 35     if ($text =~ /superpower/) {
 36         $logger->log('warn', 'superpower used');
 37         $text =~ s/superpower/secret weapon/g;
 38     }
 39     # ... more normalize rules
 40     return $text;
 41 }

И наслаждаемся тем, что тесты проходят и все отлично! Ура.

$ prove t-human.t
t-human.t .. 1/? 
#   Failed test at t-human.t line 23.
#          got: 'i wan o us suprpowr'
#     expected: 'i want to use secret weapon'
# Looks like you failed 1 test of 7.

Ого, что-то пошло не так. Ну конечно! Наша новая логика вырезает слишком много всего.
Немного подправим код:
 34     if ($text =~ /superpower/) {
 35         $logger->log('warn', 'superpower used');
 36         $text =~ s/superpower/secret weapon/g;
 37     }
 38     else {
 39         $text =~ s/gg|rr|e|t|q//g;
 40     }

$ prove t-human.t
t-human.t .. ok   
All tests successful.
Files=1, Tests=7,  0 wallclock secs ( 0.02 usr  0.00 sys +  0.01 cusr  0.00 csys =  0.03 CPU)
Result: PASS

Теперь все ОК!

Идеально, если тест покрывает 100% кода. Это, конечно, светлое и недостижимое будущее, но по крайней мере, мы можем хотя бы стремиться к этому.
Покрытие можно замерить с помощью Devel::Cover.
$ perl -MDevel::Cover t-human.t 

Devel::Cover: Writing coverage database to /home/wwax/Desktop/pragmatic/1/cover_db/runs/1431793338.4403.02108
----------------------------------- ------ ------ ------ ------ ------ ------
File                                  stmt   bran   cond    sub   time  total
----------------------------------- ------ ------ ------ ------ ------ ------
Human.pm                              62.5   25.0    n/a   75.0    1.3   55.5
Logger.pm                            100.0    n/a    n/a  100.0    0.0  100.0
t-human.t                            100.0    n/a    n/a  100.0   98.6  100.0
Total                                 81.2   25.0    n/a   90.0  100.0   75.7
----------------------------------- ------ ------ ------ ------ ------ ------

Нам важна только первая строка. Неплохие результаты, учитывая, что до этого никакого тестирования там вообще не было.
Если в модуле Human.pm оставить только единственную функцию _normalize ради которой это все затевалось, то cover показывает 100% =)
Это значит, что все функции, операторы и ветвления были пройдены в результате нашего теста.

----------------------------------- ------ ------ ------ ------ ------ ------
File                                  stmt   bran   cond    sub   time  total
----------------------------------- ------ ------ ------ ------ ------ ------
Human.pm                             100.0  100.0    n/a  100.0    1.2  100.0

Успешного рефакторинга и надеюсь, будет продолжение =)
Savenkova Natalya
